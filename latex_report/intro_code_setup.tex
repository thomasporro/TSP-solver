Section \ref{chapter:primo_capitolo} described the problem and stated that is NP-hard. The computational effort to obtain an optimal solution to this problem is high. Due to this fact, the implementation will be done using the programming language C which will provide really good efficiency and better memory management than other languages.

All the results obtained in this report were executed on a Linux machine with Ubuntu 20.04 as operative system. The system runs an Intel Core i7 8550u @1.80Ghz with 16Gb of RAM.

To produce this code a lot of software was used. The main IDE used in this project is CLion by IntelliJ, CMake is the build software used to compile the code. The most important software used is IBM ILOG CPLEX which is an optimization software package, its integration in the code is done through the use of the Callable Library (API). This software isn’t usually free but it was made available free of charge for students that needed it for academic purposes.

During this report the TSP problem may have some fractional solution, to deal with them the external library Concorde has been used. (Non ricordo se l'ho già spiegata nella sezione)

To visualize the solution found the Gnuplot library has been used, which is a command-line driven utility. The main usage was to check the effect of the code written to the TSP instances. The graphs of this report are generated exploiting the command line and using Gnuplot through a pipe.

To analyze the efficiency of the algorithms presented a performance profile tool has been used. This tool is written by Salvagnin (2019) and it is for internal use only.

\section{Solution and data management}
\label{sec:solution-data-management}
To evaluate the method implemented a reference library has been adopted. TSPLIB \cite{tsp-lib} is a library of sample instances for the TSP (and related problems) from various sources and of various types. This allowed having a starting point on the information needed to solve the problem. Among all the sections contained in the $.tsp$ files only, the most important ones are stored into the instance which are:
\begin{itemize}
	\item DIMENSION: the number of nodes that are in the file;
	\item EDGE WEIGHT TYPE: the typology of the distance between the nodes;
	\item NODE COORD SECTION: section, usually it goes at the end of the file, where the coordinates of the nodes are described.
\end{itemize}

To store the solution in a convenient and useful way the notion of a successor is introduced. Indeed the solution of the TSP problem is a cycle, so each node has a successor. Considering an array big as the number of nodes in the problem, the index of the array is node number and its content is the number of the next node in the solution. In this way each node points to its successor and going through it is possible to generate the solution.

\section{CPLEX's variables and constraints}
Understanding how CPLEX build and manage constraint is important to have full control over the system. 

The whole software works with the concept of rows and columns, which are respectively the constraints and the variables of the problem. To understand better I will give you an example with a simple minimisation problem, where $x_i$ is an integer value:

\begin{equation}
\label{eqn:cplex-example}
\begin{array}{lllllll}%
\text{min}  &x_1 	&+ 	& 3x_2 &+ & x_3\\
&  2x_1 &  	&   &- &x_3 &\le 60\\
&		&	& 4x_2 & + &7x_3 &\ge 20\\
\end{array}\\
\end{equation}

This problem can be seen as a matrix composed of rows and columns, each column corresponding to a variable, each row corresponding to a constraint that the problem has to satisfy. Whenever it is necessary to add a new variable, $x_4$ for example, it is possible to do so just by calling the API and adding a new column to the problem. The same can be done with a constraint, it can be added by inserting a new row using the callable library.

When a new constraint is added it contains only the right-hand side of the equation/inequation, all the coefficients of the variables are setted to 0. The constraint will appear as following:

\begin{equation}
\label{eqn:constraint}
\text{*empty*} \qquad \le 60
\end{equation}

Inequation \ref{eqn:constraint} is the first row of the model described in \ref{eqn:cplex-example}.
To change the value of the coefficients to be consistent with the model of this section it is possible to use the API of CPLEX. So it is possible to set the value of the variable $x_1$ to $2$ and $x_3$ to $-1$. Resulting as following: 

\begin{equation}
\label{eqn:full-constraint}
2x_1-x_3 \le 60
\end{equation}

This operation is done every time a new constraint is added to the instance.
The Callable Library has also other methods to add new constraints but this one is the one used during this project.