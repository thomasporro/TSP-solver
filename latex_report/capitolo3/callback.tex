In the previous section, the Benders method reaches the optimal solution of the problem through multiple calls of the CPLEX optimizer. This is done by adding the sub-tour elimination constraints if the solution found is composed of various tours. The purpose of this section is to introduce a different approach: I will exploit the branch-and-cut technique through the use of the CPLEX callbacks.\\
The API by IBM's software grants the use of some callbacks during the optimization process. CPLEX provides a wide range of possibilities such as informational callbacks, query/diagnostic callbacks, and control callbacks. The first ones give the user additional information on the current optimization without affecting the performance or interfering with the solution search space. The second ones access to more detailed information compared to the informational callbacks, but they can affect the overall performance of the problem resolution; the query/diagnostic callbacks are also incompatible with the dynamic search and the deterministic parallel functions.  The last ones are the one I am going to use and they allow the user to alter and customize how CPLEX performs the optimization.\\

During the optimization process, CPLEX will find numerous possible solutions. \\Letâ€™s assume that a candidate solution $x^*$ is found during the operation. Then, if the cost of this new result is better than the previous one the software will update the current best solution with the last found. Otherwise, the solution is considered infeasible and it is rejected by the system.\\
The \textsc{CPXcallbacksetfunc} method will set my custom callback that will be used every time a candidate solution is found. The algorithm adopts the same method explained in section \ref{chapter:benders} (\textsc{build\_solution}): if more than one connected component is found, a new SEC is added to the instance of the problem and the candidate solution is rejected (through the function \textsc{CPXcallbackrejectcandidate}).\\
The relevant difference between this implementation and the Benders method is that, while the latter needs the iteration of various optimizations processes, the former rejects the possible solution aforehand provided to the user.
The algorithm used here is the following:
\begin{algorithm}
	\caption{Callback method}\label{algo:callback}
	\begin{algorithmic}[1]
		\Require $G=(V,E), c:E\rightarrow \Re^+$
		\Ensure $z^*\text{ optimal solution}$
		\Procedure{Main}{$G=(V,E), c:E\rightarrow \Re^+$}
		\State instance $\gets$ *initializing basic model*
		\State instance $\gets$ *instance $\cup$ custom callback*
		\State $z^*$ $\gets$ \textsc{CPXmipopt}
		\State \Return $z^*$
		\EndProcedure
		
		\Procedure{customCallback}{$z$}
			\State ncomp $\gets$ \textsc{build\_solution}($z)$
			\If{$ncomp > 1$}
				\State *Add SEC and reject candidate solution*
			\EndIf
			\State \Return
		\EndProcedure
		
	\end{algorithmic}
\end{algorithm}