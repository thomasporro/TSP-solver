The model produced by Miller, Tucker, and Zemlin bypasses the exponential SECs by reducing their number to a simple polynomial.  Differently from the basic model, the graph obtained in this case is asymmetrical: $x_{ij}$ and $x_{ji}$ can have different weights.

In the new formulation, a new variable called $u_i$ is assigned to each node of the solution. This number represents an increasing sequence number in the optimal tour: starting from the second one ($u_2=0$), each node will increase the value by 1 at each following node until the end of the solution ($u_n=n-2$). The first node is considered special and its value is always set to $0$.

This is the new constraint added to the basic model by MTZ:
%\begin{comment}
	\begin{equation}
	\label{eqn:big-m}
	u_i-u_j+nx_{ij}\le n-1; \quad i,j\in \{2, \dots, n\}, i \not=j
	\end{equation}
	\begin{equation}
	\label{eqn:u-bound}
	0 \le u_i \le n-2; \quad integer \quad i \in V:i>1
	\end{equation}
%\end{comment}


The meaning of this formulation is the following: if the arc $x_{ij}$ is selected, then the value of $u_j$ is $u_j \ge u_i+1$ .

\subsection{Implementation of the model}
To express \ref{eqn:big-m} as a CPLEX constraint I need to rewrite the inequation in a way called Big-M. This method expects a new variable called $M$, which allows the system to activate or deactivate the constraint in a simple way. The new constraint will be:

\begin{equation}
\label{eqn:big-m-trick}
u_j\ge u_i+1-M(1-x_{ij})
\end{equation}

With this approach, the constraint is strictly depending on the value of $x_{ij}$. If $x_{ij}=1$, the constraint works like a normal one because the value of $M(1-x_{ij})$ will be $0$, so the meaning of \ref{eqn:big-m-trick} will be the same as the one expressed in the previous section. 
If $x_{ij}=0$, the right-hand side of the inequation will be certainly negative, making the constraint deactivated and allowing $u_j$ to take up any possible value from $0$ to $n-2$. Between all the values that $M$ can assume, the smallest one is $n-1$ due to the fact that, in the case of $X_{ij}=0$, the constraint will be still useful even if $u_i$ reaches its case limit of $n-2$.

With the application of the Big-M trick, the constraints can be written in the CPLEX environment. There are substantially 3 methods that can be implemented in the framework:

\begin{itemize}
	\item the use of standard constraints: all the constraints wrote in \ref{eqn:big-m} are directly saved into the problem at once. This lead to have $O(n^2)$ constraints active, making the optimization too large or even too expensive to solve;
	
	\item the use lazy constraints: as the name suggests, here the constraints are applied lazily. This means they are not always applied to the problem because CPLEX uses them only when necessary. In doing so, a pool of constraints is created and every time an integer optimal solution is found, the violation of every constraint in the pool is checked.
	If one of them is infringed, this constraint is added permanently to the instance. This method will hopefully make the problem smaller and faster to be solved than the one created with the standard constraints;
	
	\item the use of indicator constraints: in the first two cases the Big-M trick is used to trigger a constraint when a particular variable assumes a predetermined value, but this method is not always preferable since it can behave in unstable ways. That is why a good implementation of \ref{eqn:big-m} is the usage of the indicator constraints provided by the CPLEX API: this method automatically activates the constraint $u_j \ge u_i + 1$ when the $x_{ij}$ assumes the user passed value.
\end{itemize}